for (clade in HV_Clades$Clade_1){
CT <- Common %>% filter(Clade_1 == clade, Ecotype == "Athaliana")
CT %>% select(Gene, Clade_1, HV) %>% print(n=100)
}
for (clade in HV_Clades$Clade_1){
CT <- Common %>% filter(Clade_1 == clade, Ecotype == "Athaliana", Allele == 1)
CT %>% select(Gene, Clade_1, HV) %>% print(n=100)
}
#############
Common %>% filter(HV==1) %>% select(Clade_0) %>% distinct() -> HV_Clades
for (clade in HV_Clades$Clade_0){
CT <- Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele == 1)
CT %>% select(Gene, Clade_0, HV) %>% print(n=100)
}
#############
Common %>% filter(HV==1) %>% select(Clade_0) %>% distinct() -> HV_Clades
for (clade in HV_Clades$Clade_0){
CT <- Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele == 1)
CT %>% select(Gene, Clade_0, HV) %>% distinct() %>% print(n=100)
}
for (clade in HV_Clades$Clade_0){
CT <- Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele == 1)
CT %>% select(Gene, Clade_0, HV) %>% distinct() %>% arrange(Gene) %>% print(n=100)
}
Common %>% filter(Clade_0 == "Int13214_238", HV == 1, Allele == 1)
Common %>% filter(Clade_0 == "Int13214_238", HV == 1, Allele == 1) %>% print(n=100
)
#Set Working Directory-----------------------------------
setwd(dir = "~/BioInf/Zenodo/hvNLR/Analysis/")
#Loading libraries-----------------------------------------
library(msa)
library(entropy)
#library(odseq)
library(tidyverse)
'%ni%' <- Negate("%in%")
#Get list of genes to produce Entropy plots for-------
getwd()
(genes<-read_delim("AthaHV.txt",col_names = c("Gene","CommonName"),delim = "\t" ))
genes %>% print(n=200)
#Get the associated clades and alignment files from Atha_NLRome_CladeAnalysis.R output i.e. the main tibble called Common-----
Common <- read_delim("../Athaliana_NLR_Phylogeny/Atha_NLRome_GeneTable.txt",delim = "\t")
(CladesFiles<- Common %>% filter(Gene %in% genes$Gene))
## Change the relative path to work from current directory
CladesFiles <- CladesFiles %>% mutate(File = str_replace(File,'../','../Athaliana_NLR_Phylogeny/'))
CladesFiles %>% select(File)
left_join(genes,CladesFiles) %>% arrange(Clade) %>% select(Gene,CommonName,Clade) %>% print(n=40)
setwd("~/Dropbox/RPP13/")
#Loop that imports alignments one at a time and appends dataframe with columns of entropy values--------
Alph_21 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V","-")
Alph_20 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V")
genes[[20]]
genes[20,
genes[20,]
genes[20,]
genes %>% filter(CommonName =="RPP13")
genes %>% filter(CommonName =="RPP13")->genes
#Reading in sequence alignment-----------------------------
j <- 1
gene <- genes$Gene[[j]]
CN <- genes$CommonName[[j]]
file <- (CladesFiles %>% filter(Gene == gene))$File
maa <- readAAMultipleAlignment(file)
file <- "output.best.fas"
maa <- readAAMultipleAlignment(file)
maa
#Masking columns by reference gene----------------
RefGene <- "RPP13_Col0"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
RefSeq
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
RefAli <- as(maa, "AAStringSet")
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-paste0("EntropyNoGaps_",gene)
entNG
which(entNG[,1] > 2.5)
entNG %>% mutate(ResNum = 1:nrow(entNG))
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >2.5)
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >0.5)
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >1.5)
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >1.5) %>% print(n=100)
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >1.5) %>% select(ResNum) %>% print(n=100)
#Masking columns by reference gene----------------
RefGene <- "RPP13_NdA"
file <- "output.best.fas"
maa <- readAAMultipleAlignment(file)
#Masking columns by reference gene----------------
RefGene <- "RPP13_NdA"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
RefAli <- as(maa, "AAStringSet")
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-paste0("EntropyNoGaps_",gene)
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >1.5) %>% select(ResNum) %>% print(n=100)
RefSeq
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
RefSeq
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
RefAli <- as(maa, "AAStringSet")
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-paste0("EntropyNoGaps_",gene)
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(EntropyNoGaps_Athaliana_AT3G46530.1 >1.5) %>% select(ResNum) %>% print(n=100)
entNG %>% mutate(ResNum = 1:nrow(entNG), Ent= entNG[1,]) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-"Ent"
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
RefAli <- as(maa, "AAStringSet")
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-"Ent"
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
gene <- "RPP13_Col0"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
RefAli <- as(maa, "AAStringSet")
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-"Ent"
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
if (!dir.exists("Test")){dir.create("Test")}
OutputDirectory <- paste0("Test/",gene,"_",CN,"/")
if (!dir.exists(OutputDirectory)){dir.create(OutputDirectory)}
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
setwd("~/Dropbox/RPP13/")
#Loop that imports alignments one at a time and appends dataframe with columns of entropy values--------
Alph_21 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V","-")
Alph_20 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V")
file <- "output.best.fas"
maa <- readAAMultipleAlignment(file)
maa
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
(RefSeq) <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))]
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
(RefAli <- as(maa, "AAStringSet"))
RefLen <- width(RefAli[1])
setwd("~/Dropbox/RPP13/")
#Loop that imports alignments one at a time and appends dataframe with columns of entropy values--------
Alph_21 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V","-")
Alph_20 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V")
file <- "output.best.fas"
maa <- readAAMultipleAlignment(file)
maa
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
GapMask
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
(RefAli <- as(maa, "AAStringSet"))
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-"Ent"
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
gene <- "RPP13_Col0"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
gene <- "RPP13_Col0"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
gene
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
gene
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
gene <- "RPP13_Col0"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
AliLen <- width(RefSeq)
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
maa <- readAAMultipleAlignment(file)
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
#gene <- "RPP13_Col0"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
AliLen <- width(RefSeq)
setwd("~/Dropbox/RPP13/")
#Loop that imports alignments one at a time and appends dataframe with columns of entropy values--------
Alph_21 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V","-")
Alph_20 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V")
file <- "output.best.fas"
maa <- readAAMultipleAlignment(file)
#Masking columns by reference gene----------------
gene <- "RPP13_NdA"
#gene <- "RPP13_Col0"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
(RefAli <- as(maa, "AAStringSet"))
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-"Ent"
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
setwd("~/Dropbox/RPP13/")
#Loop that imports alignments one at a time and appends dataframe with columns of entropy values--------
Alph_21 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V","-")
Alph_20 <- c("A","R","N","D","C","Q","E","G","H","I","L","K","M","F","P","S","T","W","Y","V")
file <- "output.best.fas"
maa <- readAAMultipleAlignment(file)
#Masking columns by reference gene----------------
#gene <- "RPP13_NdA"
gene <- "RPP13_Col0"
(RefSeq <- as(maa, "AAStringSet")[grep(pattern = gene, x=rownames(maa))])
AliLen <- width(RefSeq)
GapMask<- NULL
for (i in 1:AliLen){
c<-as.vector(RefSeq[[1]][i]) %in% c("-")
GapMask<-append(GapMask,c,length(GapMask))
}
colmask(maa) <- IRanges(GapMask)
#Masking reference genes---------------------------
RefIDs <- grep(pattern = "Athaliana", x=names(unmasked(maa)))
rowmask(maa) <- IRanges(start = RefIDs, end = RefIDs)
#Retrieving the non-masked subset------------------
(RefAli <- as(maa, "AAStringSet"))
RefLen <- width(RefAli[1])
## Calculating Consensus Matrix
(Tidy_CM<-as_tibble(t(consensusMatrix(RefAli, baseOnly = T))))
## Compensating for consensus matrix not keeping full alphabet in output
for (a in setdiff(Alph_21,colnames(Tidy_CM))){
vec <- as_tibble(0*(1:nrow(Tidy_CM)))
colnames(vec) <- paste(a)
Tidy_CM <- as_tibble(cbind(Tidy_CM,vec))
}
##Selecting relevant columns
(Tidy_CM_NoGaps <- select(Tidy_CM,all_of(Alph_20)))
##Entropy Calculation Ignoring Gaps
entNG <- apply(Tidy_CM_NoGaps, 1, entropy,unit="log2") %>% as_tibble()
colnames(entNG)<-"Ent"
entNG %>% mutate(ResNum = 1:nrow(entNG)) %>% filter(Ent >1.5) %>% select(ResNum) %>% print(n=100)
setwd("~/Dropbox/BCSB/Impact/AutomatedRetreaval/")
#install.packages("devtools")
#library(devtools)
#devtools::install_github("ropensci/RefManageR")
#devtools::install_github("r-lib/gmailr")
##customReport obtained from "http://www.rcsb.org/pdb/rest/customReport.csv?pdbids=*&customReportColumns=structureId,structureTitle,experimentalTechnique,releaseDate,pubmedId,diffractionSource,publicationYear&service=wsfile&format=csv"
library(tidyverse)
library("RefManageR")
'%ni%' <- Negate('%in%')
###Retrieve data from RCSB###
link <- "http://www.rcsb.org/pdb/rest/customReport.csv?pdbids=*&customReportColumns=structureId,structureTitle,experimentalTechnique,releaseDate,pubmedId,diffractionSource,publicationYear&service=wsfile&format=csv"
Pdb_Data <- as_tibble(read.csv(curl::curl(link),header = T,sep = ","))
Pdb_Data <- mutate(Pdb_Data,releaseDate = as.Date(as.character(Pdb_Data$releaseDate)))
Pdb_Data %>% filter(diffractionSource %in% BCSB) %>% arrange(releaseDate) %>% filter(releaseDate > "2020-01-01") %>% print(n=1000)
BCSB <- c("ALS BEAMLINE 5.0.3","ALS BEAMLINE 5.0.2","ALS BEAMLINE 5.0.1","ALS BEAMLINE 8.2.1","ALS BEAMLINE 8.2.2")
Pdb_Data %>% filter(diffractionSource %in% BCSB) %>% arrange(releaseDate) %>% filter(releaseDate > "2020-01-01") %>% print(n=1000)
Papers2020 <- Pdb_Data %>% filter(diffractionSource %in% BCSB) %>% filter(publicationYear == 2020) %>% select(pubmedId) %>% distinct() %>% filter(!is.na(pubmedId))
Papers2020
BCSBPapers <- Pdb_Data %>% filter(diffractionSource %in% BCSB) %>% select(pubmedId) %>% distinct() %>% filter(!is.na(pubmedId))
BCSBPapers
File <- paste0("BCSB_PID_LIST_",Sys.Date(),".txt")
write_delim(BCSBPapers,path = File, delim = "\t", quote_escape = "double")
LastSet <- read_delim("BCSB_PID_LIST_2020-01-15.txt", delim = "\t")
LastSet
length(BCSBPapers$pubmedId) - length(LastSet$pubmedId)
Latest <- BCSBPapers %>% filter(pubmedId %ni% LastSet$pubmedId)
Latest
###Get references from PubMed by ID#########
PapersBib<-GetPubMedByID(Latest$pubmedId, db = "pubmed")
PaperTible <- as_tibble(PapersBib)
PaperTible
###For each missing DOI, find which beamlines contributed
###Manually deposit the relevant papers
PapersToAdd <-PaperTible$doi
colnames(PapersToAdd) <- "doi"
PapersToAdd
###For each missing DOI, find which beamlines contributed
###Manually deposit the relevant papers
PapersToAdd <-PaperTible %>% select(doi)
PapersToAdd
colnames(PapersToAdd) <- "doi"
###Getting BCSB pdbs with non-empty pubmeds
BCSB_15_20 <- Pdb_Data %>% filter(diffractionSource %in% BCSB, !is.na(pubmedId),publicationYear > 2015)
Papers_501 <- BCSB_15_20 %>% filter(diffractionSource %in% c("ALS BEAMLINE 5.0.1"),!is.na(pubmedId))
Papers_502 <- BCSB_15_20 %>% filter(diffractionSource %in% c("ALS BEAMLINE 5.0.2"),!is.na(pubmedId))
Papers_503 <- BCSB_15_20 %>% filter(diffractionSource %in% c("ALS BEAMLINE 5.0.3"),!is.na(pubmedId))
Papers_821 <- BCSB_15_20 %>% filter(diffractionSource %in% c("ALS BEAMLINE 8.2.1"),!is.na(pubmedId))
Papers_822 <- BCSB_15_20 %>% filter(diffractionSource %in% c("ALS BEAMLINE 8.2.2"),!is.na(pubmedId))
###Getting and formating bibliographies
Bib_501<-GetPubMedByID(unique(Papers_501$pubmedId), db = "pubmed")
Bib_502<-GetPubMedByID(unique(Papers_502$pubmedId), db = "pubmed")
Bib_503<-GetPubMedByID(unique(Papers_503$pubmedId), db = "pubmed")
Bib_821<-GetPubMedByID(unique(Papers_821$pubmedId), db = "pubmed")
Bib_822<-GetPubMedByID(unique(Papers_822$pubmedId), db = "pubmed")
Bib_501 <- as_tibble(Bib_501)
Bib_502 <- as_tibble(Bib_502)
Bib_503 <- as_tibble(Bib_503)
Bib_821 <- as_tibble(Bib_821)
Bib_822 <- as_tibble(Bib_822)
Attach_501 <- Bib_501 %>% select(doi)
Attach_501 <- Attach_501 %>% mutate(BL501 = "BL 5.0.1")
Full <- left_join(PapersToAdd,Attach_501,by ="doi")
Attach_502 <- Bib_502 %>% select(doi) %>% mutate(BL502 = "BL 5.0.2")
Full <- left_join(Full,Attach_502,by ="doi")
Attach_503 <- Bib_503 %>% select(doi) %>% mutate(BL503 = "BL 5.0.3")
Full <- left_join(Full,Attach_503,by ="doi")
Attach_503 <- Bib_503 %>% select(doi) %>% mutate(BL503 = "BL 5.0.3")
Full <- left_join(Full,Attach_503,by ="doi")
Attach_821 <- Bib_821 %>% select(doi) %>% mutate(BL821 = "BL 8.2.1")
Full <- left_join(Full,Attach_821,by ="doi")
Attach_822 <- Bib_822 %>% select(doi) %>% mutate(BL822 = "BL 8.2.2")
Full <- left_join(Full,Attach_822,by ="doi")
Full %>% print(n=130)
write_delim(Full,path = "MissingPapers_2020Oct16.txt", delim = "\t", quote_escape = "double",na = "")
#Set Working Directory-----------------------------------
setwd(dir = "~/BioInf/Zenodo/hvNLR/Analysis/")
#Loading libraries-----------------------------------------
library(msa)
library(entropy)
#library(odseq)
library(tidyverse)
'%ni%' <- Negate("%in%")
#Get list of genes to produce Entropy plots for-------
getwd()
(genes<-read_delim("AthaHV.txt",col_names = c("Gene","CommonName"),delim = "\t" ))
genes %>% print(n=200)
#Get the associated clades and alignment files from Atha_NLRome_CladeAnalysis.R output i.e. the main tibble called Common-----
Common <- read_delim("../Athaliana_NLR_Phylogeny/Atha_NLRome_GeneTable.txt",delim = "\t")
Common
Common %>% filter (HV ==1)
Common %>% filter (HV ==1,Ecotype =="Athaliana")%>% select(Clade_0) %>% distinct()
Common %>% filter (HV ==1,Ecotype =="Athaliana")%>% select(Clade_0) %>% distinct()->HV_Clades
Common %>% filter (HV ==1,Ecotype =="Athaliana")%>% select(Clade_0) %>% distinct()->HV_Clades
for (clade in HV_Clades$Clade_0){
Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele ==1)%>% print
}
for (clade in HV_Clades$Clade_0){
Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele ==1)%>% select (Gene, Clade_0, HV) %>% print
}
for (clade in HV_Clades$Clade_0){
Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele ==1)%>% select (Gene, Clade_0, HV) %>% distinct() %>% print
}
for (clade in HV_Clades$Clade_0){
Common %>% filter(Clade_0 == clade, Ecotype == "Athaliana", Allele ==1)%>% select (Gene, Clade_0,Clade, HV) %>% distinct() %>% print
}
